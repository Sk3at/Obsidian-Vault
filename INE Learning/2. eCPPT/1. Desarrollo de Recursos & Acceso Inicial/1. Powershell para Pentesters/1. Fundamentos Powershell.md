¿Qué es Powershell?
Powershell es un poderoso interprete de linea de comandos y esta orientado al scripting, puede ser encontrado en la mayoría de los sistemas operativos Windows.
Powershell es utilizado típicamente por administradores ya que provee una gran funcionalidad y flexibilidad para administrar sistemas Windows y automatizar tareas, lo que lo hace una excelente herramienta para el proceso de pentesting.
Como esta ligeramente integrado con el .NET framework contiene acceso conveniente al API de .NET asi como al component object model (COM) y al Windows management instrumentation (WMI), lo que nos da un plus al momento de establecer persistencia asi como tambien al recopilar informacion en un objetivo.
La mayor parte del tiempo trabajaremos con scripts identificado con la extencion .ps1 o por aquellos que son conocidos como cmdlets (comandos nativos de powershell).

¿Por que Powershell?
El uso de powershell nos permite tomar ventaja utilizando herramientas que esta dentro del sistema Operativo una vez que obtuvimos acceso al mismo.
Algunas de las ventajas son:
- Muchas organizaciones no rastrean/monitorean la actividad de powershell.
- Podemos utilizar powershell para correr, descargar o ejecutar codigo dentro del proceso de memoria del ejecutable powershell, ayudandonos a evadir soluciones de seguridad del endpoint.
- Podemos utilizarlo para interactuar con .NET y otras APIs de Windows.
- Podemos utilizar funciones DLL desde dentro de powershell.
- Podemos ejecutar aplicaciones que no se encuentren en la whitelist.
- Existen numerosas herramientas disponibles para pentesting (https://github.com/PowerShellMafia/PowerSploit)

Powershell CLI
La CLI de powershell nos provee con acceso a cmdlets, modulos, funciones y nos prevee un metodo para crear tareas, funciones, variables y mas de forma directa.
En la mayoria de los casos se puede acceder al CLI tipeando en la barra de busqueda "powershell".
![](../../Images/Pasted%20image%2020240328155659.png)
En ocaciones donde el acceso directo a powershell no se encuentre disponible podemos encontrarlo en:
- 64bits: C:\\windows\\system32\\WindowsPowerShell
- 32bits: C:\\windows\\SysWOW64\\WindowsPowerShell
![](../../Images/Pasted%20image%2020240328160147.png)
Podemos chequear si el proceso de powershell que ejecutamos es de 64bits con el comando Environment::Is64BitProcess
El cual retornara True si es de 64.
![](../../Images/Pasted%20image%2020240328160454.png)
Cuando sea posible debemos ejecutar powershell como administrador ya que sino tendremos privilegios minimos de usuario.

USO BASICO
Podemos ver la ayuda en poweshell con el comando /?, -Help o -?
![](../../Images/Pasted%20image%2020240328202808.png)
Los siguientes son los comandos que mas utilizaremos para nuestros propositos de pentest.
La powershell tiene una politica de ejecucion que determina que scripts pueden ser utilizados, esta politica puede ser desabilitada con -ExecutionPolicy Bypass o -ExecutionPolicy Unrestricted utilizadas como argumento en algun script que queramos utilizar.
![](../../Images/Pasted%20image%2020240328203047.png)
Tambien existe la -WindowsStyle Hidden que nos permite si estuvieramos en un reverse shell ejecutar algun comando o script de powershell sin que se abra el powershell en el objetivo (lo cual es importante si hay algun usuario utilizando la maquina en ese momento).
![](../../Images/Pasted%20image%2020240328203238.png)
Con el parametro -Command podemos especificar que powershell corra algun comando o ejecute un script block (una secuencia de scripts).
![](../../Images/Pasted%20image%2020240328203415.png)
Podemos realizar un downgrade de la version de powershell con el parametro -Version.
![](../../Images/Pasted%20image%2020240328203544.png)
Muchos de los parametros pueden ser abreviados:
![](../../Images/Pasted%20image%2020240328203619.png)

GET-HELP
Una de las caracteristicas mas utililes en la CLI de Powershell es el cmdlet "Get-Help", este es similar a las Man Pages en Unix. Podemos utilizar el Get-Help para obtener informacion sobre cualquier funcion, alias, modulo o cmdlet que este disponible en Powershell.
Podemos utilizarlo incluyendo el nombre de la funcion que queremos mas informacion y como argumento el Get-Help.
Por ejemplo, hagamos un Get-Help de Get-Help.
![](../../Images/Pasted%20image%2020240329152153.png)
Observamos que nos da el nombre del cmdlet, el alias, su sintaxis y una nota explicativa, pero esto no es todo, si quisieramos informacion mas detallada podemos agregar el argumento -Full quedando asi: Get-Help Get-Help -Full.
![](../../Images/Pasted%20image%2020240329152550.png)
Tambien podemos obtener ejemplos de uso de un cmdlet especifico utilizando el parametro -Examples.
![](../../Images/Pasted%20image%2020240329153325.png)
Como observamos, se obtienes varios ejemplos del cmdlet, esto puede ser muy utili, en este caso particular si buscamos un proceso determinado.

GET-COMMAND
El cmdlet "Get-Command" es otro bastante util, ya que nos permite listar todos los cmdlets, alias, funciones, workflows, filtros y scripts disponibles para powershell.
Correr el cmdlet "Get-Command" sin ningun argumento nos listara simplemente todos los comandos, pero podemos utilizar el parametro -Name para verificar si el que estamos buscando se encuentra disponible.
![](../../Images/Pasted%20image%2020240329153734.png)
Como podemos observar nos dice tambien la version de cada uno, asi como tambien estan divididos por tipos de comandos.
Por ejemplo, si buscaramos algo con relacion al Firewall podriamos buscar de la siguiente forma: Get-Command -Name Firewall
![](../../Images/Pasted%20image%2020240329154052.png)

CMDLETS
Antes de continuar, aclaremos que es o puede ser un cmdlet:
- Scripts de "bajo peso" en Powershell que llevan a cabo una sola una sola funcion (pueden ser tan pequeños como unas pocas lineas de codigo).
- Instancias de .Net Framework classes derivadas de Cmdlet Base Class que proveen acceso a funciones del sistema.
- Los cmdlets son comandos nativos de Powershell (aunque podemos crear los nuestros).
- Tipicamente su nombre esta compuesto por "Verbo-Sustantivo" lo que ayuda a determinar su funcion. Por ejemplo, Invoke-Command; Get-Help; etc.
- Pueden ser utilizados para dar su output a otro cmdlet para que sea procesado con un pipeline (|).
- Cada uno de los cmdlets tienen su propio set de parametros que pueden ser descubiertos con el uso del Get-Help como vimos anteriormente.
Es importante destacar que la mayoria de los cmdlets por defecto cuando son utilizados sin otro parametro retornan un set limitado de informacion o columnas.
Por ejemplo si corremos el cmdlet Get-Childitem sin ningun argumento u opcion, este retornara cuatro columnas llamadas mode, lastwritetime, length y name.
![](../../Images/Pasted%20image%2020240329155318.png)
Si realizamos un piping del output al Format-List cmdlet, en lugar de columnas veremos todas las propiedades asociadas con sus objetos en un formato distinto, lo cual nos trae muchos mas detalles.
![](../../Images/Pasted%20image%2020240329155737.png)
El resultado de salida de todos los cmdlets, son generalmente conocidos como objetos.
Estos objetos pueden ser procesados usando los que conocemos como pipelining, que es similar a como encadenamos comandos en la bash de linux con el operador |.
Un ejemplo de procesar los objetos de salidar con pipelines seria similar a lo siguiente:
Get-Process | Sort-Object -Unique | Select-Object ProcessName
El comando de arriba nos retornara un lista de los procesos (Get-Process), luego ordenara la lista (Sort-Object) con el parametro -Unique y finalmente selecciona el objeto "ProcessName" (Select-Object ProcessName) para devolvernos una lista unica de nombres de procesos.
![](../../Images/Pasted%20image%2020240329160444.png)
Tambien podemos redireccionar los resultados utililzando el operador >.
![](../../Images/Pasted%20image%2020240329160629.png)


GET-PROCESS
Ejecutar el cmdlet "Get-Process" sin nigun argumento retornara infromacion basica sobre los mismos en un formato de columnas.
![](../../Images/Pasted%20image%2020240329161601.png)
Si queremos obtener toda la informacion (propiedades) asociadas con los procesos podemos utilizar un pipe y darle formato de lista "Format-List", esto nos da una mejor idea de como podemos filtrar los datos por propiedades especificas.
![](../../Images/Pasted%20image%2020240329161809.png)
Podemos extender esto para obtener informacion especifica sobre los procesos y los paths de sus ejecutables utilizando el cmdlet Format-List y agregando la prppiedad Path a la misma.
Supongamos en este ejemplo que queremos visualizar el path de chrome.
![](../../Images/Pasted%20image%2020240329162205.png)
Podemos agregar mas propiedades, por ejemplo:
![](../../Images/Pasted%20image%2020240329162440.png)

GET-CHILDITEM
Es bueno saber que la mayoria de los cmdlets tiene aliases, por ejemplo el cmdlet "Get-ChildItem" que simplemente lista los archivos de un directorio puede ser alternativamente utilizado con el comando "ls".
![](../../Images/Pasted%20image%2020240329190914.png)
Para saber cual es el alias de un cmdlet especifico podemos utilizar el "Get-Alias" con el parametro -Definition seguido del nombre del cmdlet, por ejemplo:
![](../../Images/Pasted%20image%2020240329191108.png)
Como podemos ver, tenemos varios alias para utilizar el Get-ChildItem, ls, dir, gci.

GET-WMIOBJECT
Otro alias que veremos seguido es "select" cuando es usado en conjuncion con otros cmdlets en operaciones con pipeline, y es el alias de "Select-Object".
En este ejemplo vamos a utilizar el cmdlet "Get-WmiObject" cmdlet (usado para devolver informacion sobre objetos WMI) en conjunto con otros parametros y argumentos para obetener informacion relacionada al sistema operativo.
Get-WmiObject -class win32_operatingsystem | select -Property *
![](../../Images/Pasted%20image%2020240329192030.png)
Alternativamente podemos usar el Format-List alias "fl" para obtener la misma lista de todas las propiedades del WMI.
Get-WmiObject -class win32_operatingsystem | fl *
![](../../Images/Pasted%20image%2020240329192211.png)


SELECT-STRING
El cmdlet Select-String en conjunto con los argumentos -Path y -Pattern es otro comando util de PowerShell que podemos utilizar para encontrar archivos que contengan determinados strings.
En el ejemplo debajo, buscamos algun archivo txt dentro de los documentos del usuario.
Select-String -Path C:\\Users\\Skreat\\Documents\\\*.txt -Pattern pass\*
![](../../Images/Pasted%20image%2020240329193800.png)

GET-CONTENT
Con el cmdlet Get-Content podemos obtener el contenido completo dentro de un archivo (seria como el cat en Unix).
![](../../Images/Pasted%20image%2020240329194042.png)

GET-SERVICE
El cmdlet Get-Service nos dara informacion sobre los servicios instalados, lo cual puede ser util en caso de que queramos identifical algun servicio que pueda ser vulnerable a escalacion de privilegios.
Correr el comando sin argumentos retornara una lista simple de tres columnas.
![](../../Images/Pasted%20image%2020240329194439.png)
Podemos ordenar nuestros servicios con el cmdlet Sort.Object, en el siguiente ejemplo ordenamos todos los servicios que comienzen con "s" en orden decendente de acuerdo a la propiedad "Status"
Get-Service “s*” | Sort-Object Status -Descending
![](../../Images/Pasted%20image%2020240329194707.png)



MODULOS
Un modulo en terminos simples es un conjunto de funcionabilidades de Powershell agrupadas en la forma de un archivo que generalmente tiene la extension ".psm1". Los modulos se componen de diversos componentes, pero no todos los componentes son necesarios para que el modulo funcione.
Los componentes que hacen a un modulo son:
- Cualquier numero de powershell scripts (.ps1) u otros archivos de codigo.
- Ensambles adicionales como archivos de ayuda.
- Un manifiesto del mudulo.
- Un directorio el cual contiene todo lo listado.
Existen diferentes tipos de modulos:
- Modulos script (con los que mas trabajaremos).
- Modulos binarios.
- Modulos de manifiesto.
- Modulos dinamicos (creados dinamicamente con scripts utilizando el cmdlet New-Module).

GET-MODULE
Los modulos son generalmente importados a nuestra sesion de Powershell, para obtener una lista de todos los modulos importados podemos utilizar el cmdlet Get-Module.
![](../../Images/Pasted%20image%2020240329202102.png)
Tambien podemos listar los modulos que podemos importar con el parametro -ListAvailable.
![](../../Images/Pasted%20image%2020240329202218.png)
Si vemos algun modulo que queremos utilizar primero debemos importarlo a nuestro Powershell actual, esto puede ser realizado con el cmdlet Import-Module.
![](../../Images/Pasted%20image%2020240329202321.png)
Una vez que importamos un modulo, todos sus cmdlets y otros componentes estaran disponibles para nosotros y podremos ejecutar esos cmdlets que son parte del modulo.
Por ejemplo, si quisieramos importar el framework PowerSploit primero deberiamos descargar todo el paquete en nuestra maquina local.
Este paquete debe ser copiado en uno de los path de modulo especificados en la variable “$Env:PSModulePath”. Para ver estos paths simplemente lo tipeamos en consola
![](../../Images/Pasted%20image%2020240329202750.png)
![](../../Images/Pasted%20image%2020240329202834.png)
Una vez que creamos nuestro archivo PoweSploit dentro de uno de los paths podemos importar todos los modulos de PowerSploit con el cmdlet Import-Module.
![](../../Images/Pasted%20image%2020240329203010.png)
Y podemos verificar si se encuentra disponible con Get-Module
![](../../Images/Pasted%20image%2020240329203028.png)
Para listar todos los cmdlets asociados al modulo PowerSploit podemos utilizar el Get-Command y especificar el modulo con -Module.
![](../../Images/Pasted%20image%2020240329203132.png)
![](../../Images/Pasted%20image%2020240329203145.png)
Asi mismo podemos utilizar el cmdlet Get-Help para verificar que hace cada cada uno de los cmdlets disponibles en PowerSploit.


POWERSHELL SCRIPTS
Los scripts son otra pieza fundamental como herramienta ofensiva en powershell. Generalmente se definen con la extension .ps1, donde el 1 no indica la version de powershell, sino su motor.
Los scripts de powershell pueden contener pocos o varios comandos para automatizar tareas o pueden ser tan complejos como para contener parametros, argumentos, loops, funciones y todo lo relativo que puede ofrecer powershell como lenguaje de script.
Correr un script en powershell es tan simple como llamarlo desde la consola utilizando el .\\ (siempre que estemos en el mismo directorio).
![](../../Images/Pasted%20image%2020240331191030.png)
Deberemos hacer un bypass de la ExecutionPolicy antes de ejecutar el script de nuestra eleccion.
El siguiente es un ejemplo basico de un script que toma el nombre de un archivo como argumento para crear la variable $file y ejecutar el cmdlet Get-Content en nuestra variable.
![](../../../../Pasted%20image%2020240331191626.png)
Ahora ejecutamos este script con un txt de prueba que creamos no sin antes modificar la ExecutionPolicy
![](../../../../Pasted%20image%2020240331192436.png)
Si corremos el script sin ningun parametro, powershell nos lo pedira, ya que en el script esta especificado "mandatory=$true" lo que vendria a significar que el parametro es obligatorio.
![](../../Images/Pasted%20image%2020240331192738.png)
En este punto proveemos el nombre del archivo y el script funcionara como es debido retornandonos el contenido del mismo.
![](../../Images/Pasted%20image%2020240331192847.png)
Como alternativa a este script que creamos, simplemente podriamos crear una variable con el nombre del archivo y luego hacer un Get-Content de esa variable.
![](../../Images/Pasted%20image%2020240331193002.png)
![](../../Images/Pasted%20image%2020240331193041.png)

DECLARACIONES LOOP
Un "loop" es una funcion de programacion o scripting que itera basandose en algo especifico. En otras palabras un loop ejecuta repetidamente un codigo hasta que un condicional devuelve "False" o no devuelve data adicional.
Powershell nos permite utilizar distintos tipos de declaraciones loop para nuestros propocitos:
- for()
- foreach()
- while()
- do {something} while()
- do {something} until()
Un loop generalmente se divide en dos partes, la declaracion loop y el body (el cual contiene las variables).
![](../../Images/Pasted%20image%2020240331193629.png)
En la primera linea estamos creando una variable llamada $services que retornara los objetos de Get-Service. Entonces, cuando utilicemos el "foreach()" para crear una nueva variable $service que contenga cada objeto de la variable $services, le decimos a poweshell que devuelva el nombre de cada $service con la propiedad .Name.
![](../../Images/Pasted%20image%2020240331194124.png)

Podemos utilizar varios cmdlets para contruir una declaracion loop, especificamente los cmdlets "ForEach-Object" y "Where-Object".
El ejemplo anterior puede ser realizado tambien usando los cmdlets Get-Service y ForEach-Object y un pipeline.
![](../../Images/Pasted%20image%2020240331195346.png)
![](../../Images/Pasted%20image%2020240331195507.png)
El cmdlet Where-Object nos permite seleccionar objetos basados en los valores de sus propiedades, por ejemplo en la proxima linea de comandos nos traeremos todos los servicios que tengan el valor de la propiedad de Status en Running.
![](../../Images/Pasted%20image%2020240331200108.png)




